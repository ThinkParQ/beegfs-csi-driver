/*
Copyright 2021 NetApp, Inc. All Rights Reserved.
Licensed under the Apache License, Version 2.0.
*/

package beegfs

import (
	"bytes"
	"crypto/sha1"
	"fmt"
	"io/ioutil"
	"net"
	"net/url"
	"os"
	"os/exec"
	"path"
	"strconv"
	"strings"

	"github.com/container-storage-interface/spec/lib/go/csi"
	beegfsv1 "github.com/netapp/beegfs-csi-driver/operator/api/v1"
	"github.com/opencontainers/selinux/go-selinux"
	"github.com/pkg/errors"
	"github.com/spf13/afero"
	"golang.org/x/net/context"
	"gopkg.in/ini.v1"
	"k8s.io/mount-utils"
)

// We use afero to abstract the file system. During unit tests, we use an in-memory file system (afero.NewMemFs). In an
// actual deployment, we use the host's file system.
var fs = afero.NewOsFs()
var fsutil = afero.Afero{Fs: fs}

// NewBeegfsURL converts the sysMgmtdHost and path into a URL with the format beegfs://host/path. NewBeegfsURL is
// exported for use by in test/e2e/driver.
func NewBeegfsURL(host string, path string) string {
	structURL := url.URL{
		Scheme: "beegfs",
		Host:   host,
		Path:   path,
	}
	return structURL.String()
}

// parseBeegfsURL parses a URL with the format beegfs://host/path and returns the sysMgmtdHost and path.
func parseBeegfsURL(rawURL string) (sysMgmtdHost string, path string, err error) {
	var structURL *url.URL
	if structURL, err = url.Parse(rawURL); err != nil {
		return "", "", errors.WithStack(err)
	}
	if structURL.Scheme != "beegfs" {
		return "", "", errors.New("URL has incorrect scheme")
	}
	return structURL.Host, structURL.Path, nil
}

// writeClientFiles writes a beegfs-client.conf file and optionally a connInterfacesFile, a connNetFilterFile, and a
// connTcpOnlyFilterFile to a beegfsVolume's mountDirPath. The beegfs-client.conf file is generated by reading in
// an existing beegfs-client.conf file at confTemplatePath and overriding its values with those specified in the
// beegfsVolume's config. writeClientFiles assumes an empty directory has already been created at mountDirPath.
func writeClientFiles(ctx context.Context, vol beegfsVolume, confTemplatePath string) (err error) {
	LogDebug(ctx, "Writing client files", "volumeID", vol.volumeID, "path", vol.mountDirPath)
	connAuthFilePath := path.Join(vol.mountDirPath, "connAuthFile")
	connInterfacesFilePath := path.Join(vol.mountDirPath, "connInterfacesFile")
	connNetFilterFilePath := path.Join(vol.mountDirPath, "connNetFilterFile")
	connTcpOnlyFilterFilePath := path.Join(vol.mountDirPath, "connTcpOnlyFilterFile")
	connRDMAInterfacesFilePath := path.Join(vol.mountDirPath, "connRDMAInterfacesFile")

	// setConfigValueIfKeyExists is a helper function used to get around the fact that the go-ini library will allows
	// setting the value of an arbitrary key, even if the key did not exist in the original .ini file.
	// setConfigValueIfKeyExists returns an error if the supplied key did not exist in the original .ini file.
	setConfigValueIfKeyExists := func(iniFile *ini.File, key, value string) error {
		if iniFile.Section("").HasKey(key) {
			iniFile.Section("").Key(key).SetValue(value)
		} else {
			return errors.Errorf("%v not in template beegfs-client.conf file", key)
		}
		return nil
	}

	// The BeeGFS client must bind to and listen on a UDP port. Each BeeGFS mount requires a different port. Though
	// the client is free to define and use its own port, BeeGFS does not support binding to port 0 to obtain an OS
	// assigned ephemeral port.
	var connClientPortUDP string
	port, err := getEphemeralPortUDP()
	if err != nil {
		return errors.WithMessage(err, "error selecting connClientPortUDP")
	}
	connClientPortUDP = strconv.Itoa(port)

	var clientConfBytes []byte
	var clientConfINI *ini.File
	if clientConfBytes, err = fsutil.ReadFile(confTemplatePath); err != nil {
		return errors.Wrapf(err, "error loading beegfs-client.conf file at %s", confTemplatePath)
	}
	if clientConfINI, err = ini.Load(clientConfBytes); err != nil {
		return errors.Wrap(err, "error parsing template beegfs-client.conf file")
	}
	if err = setConfigValueIfKeyExists(clientConfINI, "sysMgmtdHost", vol.sysMgmtdHost); err != nil {
		return err
	}
	if err = setConfigValueIfKeyExists(clientConfINI, "connClientPortUDP", connClientPortUDP); err != nil {
		return err
	}
	for k, v := range vol.config.BeegfsClientConf {
		if err := setConfigValueIfKeyExists(clientConfINI, k, v); err != nil {
			return err
		}
	}

	if len(vol.config.ConnInterfaces) != 0 {
		connInterfacesFileContents := strings.Join(vol.config.ConnInterfaces, "\n") + "\n"
		if err := setConfigValueIfKeyExists(clientConfINI, "connInterfacesFile", connInterfacesFilePath); err != nil {
			return err
		}
		if err = fsutil.WriteFile(connInterfacesFilePath, []byte(connInterfacesFileContents), 0644); err != nil {
			return errors.Wrap(err, "error writing connInterfaces file")
		}
	}

	if len(vol.config.ConnAuth) != 0 {
		// We don't add a newline here (as we do for the other files) because its important to maintain the exact contents
		// of connAuthFile. For raw (not base64) encoded connAuth secrets, see additional behavior in parseConnAuthFromFile.
		connAuthFileContents := vol.config.ConnAuth
		if err := setConfigValueIfKeyExists(clientConfINI, "connAuthFile", connAuthFilePath); err != nil {
			return err
		}
		if err = fsutil.WriteFile(connAuthFilePath, []byte(connAuthFileContents), 0400); err != nil {
			return errors.Wrap(err, "error writing connAuth file")
		}
	}

	if len(vol.config.ConnNetFilter) != 0 {
		connNetFilterFileContents := strings.Join(vol.config.ConnNetFilter, "\n") + "\n"
		if err := setConfigValueIfKeyExists(clientConfINI, "connNetFilterFile", connNetFilterFilePath); err != nil {
			return err
		}
		if err = fsutil.WriteFile(connNetFilterFilePath, []byte(connNetFilterFileContents), 0644); err != nil {
			return errors.Wrap(err, "error writing connNetFilter file")
		}
	}

	if len(vol.config.ConnTcpOnlyFilter) != 0 {
		connTcpOnlyFilterFileContents := strings.Join(vol.config.ConnTcpOnlyFilter, "\n") + "\n"
		if err := setConfigValueIfKeyExists(clientConfINI, "connTcpOnlyFilterFile", connTcpOnlyFilterFilePath); err != nil {
			return err
		}
		if err = fsutil.WriteFile(connTcpOnlyFilterFilePath, []byte(connTcpOnlyFilterFileContents), 0644); err != nil {
			return errors.Wrap(err, "error writing connTcpOnlyFilter file")
		}
	}

	if len(vol.config.ConnRDMAInterfaces) != 0 {
		connRDMAInterfacesContents := strings.Join(vol.config.ConnRDMAInterfaces, "\n") + "\n"
		if err := setConfigValueIfKeyExists(clientConfINI, "connRDMAInterfacesFile", connRDMAInterfacesFilePath); err != nil {
			return err
		}
		if err = fsutil.WriteFile(connRDMAInterfacesFilePath, []byte(connRDMAInterfacesContents), 0644); err != nil {
			return errors.Wrap(err, "error writing connRDMAInterfaces file")
		}
	}

	var clientConfFileHandle afero.File
	if clientConfFileHandle, err = fs.Create(vol.clientConfPath); err != nil {
		return errors.Wrap(err, "error creating beegfs-client.conf file")
	}
	if _, err = clientConfINI.WriteTo(clientConfFileHandle); err != nil {
		return errors.Wrap(err, "error writing beegfs-client.conf file")
	}

	return nil
}

// squashConfigForSysMgmtdHost takes a sysMgmtdHost and PluginConfig, which MAY have FileSystemSpecificConfigs. If
// the PluginConfig contains overrides for the provided sysMgmtdHost, squashConfigForSysMgmtdHost combines them with
// the DefaultConfig (giving preference to the appropriate FileSystemSpecificConfig). Otherwise, it returns the
// DefaultConfig.
func squashConfigForSysMgmtdHost(sysMgmtdHost string, config beegfsv1.PluginConfig) (returnConfig beegfsv1.BeegfsConfig) {
	returnConfig = *beegfsv1.NewBeegfsConfig()
	overWriteBeegfsConfig(&returnConfig, config.DefaultConfig)
	for _, fileSystemSpecificConfig := range config.FileSystemSpecificConfigs {
		if sysMgmtdHost == fileSystemSpecificConfig.SysMgmtdHost {
			overWriteBeegfsConfig(&returnConfig, fileSystemSpecificConfig.Config)
		}
	}
	return returnConfig
}

// mountIfNecessary mounts a BeeGFS file system to vol.mountPath assuming configuration files have been written to
// vol.mountDirPath by writeClientFiles.
func mountIfNecessary(ctx context.Context, vol beegfsVolume, desiredMountOpts []string, mounter mount.Interface) (err error) {
	mountOpts := constructMountOptions(ctx, desiredMountOpts, vol)

	// Check to make sure file system is not already mounted.
	notMnt, err := mounter.IsLikelyNotMountPoint(vol.mountPath)
	if err != nil {
		if os.IsNotExist(err) {
			// the file system can't be mounted because the mount point hasn't been created
			if err = os.Mkdir(vol.mountPath, 0750); err != nil {
				return errors.WithStack(err)
			}
			notMnt = true
		} else {
			return errors.WithStack(err)
		}
	}

	if !notMnt {
		// The filesystem is already mounted. There is nothing to do.
		LogDebug(ctx, "Volume is already mounted", "volumeID", vol.volumeID, "path", vol.mountPath)
		return nil
	}

	LogDebug(ctx, "Mounting volume to path", "volumeID", vol.volumeID, "path", vol.mountPath,
		"mountOptions", mountOpts)
	if err = mounter.Mount("beegfs_nodev", vol.mountPath, "beegfs", mountOpts); err != nil {
		return errors.WithStack(err)
	}
	return nil
}

// constructMountOptions takes a slice of desired mount options and a beegfsVolume. If the slice is empty, it returns
// a slice of default mount options with the cfgFile option necessary to mount BeeGFS included. If the slice is
// not empty, it returns a sanitized version of the slice with the required cfgFile option. If SELinux is enabled,
// a security context mount option is always included in the return.
func constructMountOptions(ctx context.Context, desiredMountOpts []string, vol beegfsVolume) []string {
	var mountOpts []string
	if len(desiredMountOpts) == 0 {
		// If no mount options are specified, use these defaults.
		// We set the nosuid mount option by default to adhere to BeeGFS security recommendations.
		mountOpts = []string{"rw", "relatime", "cfgFile=" + vol.clientConfPath, "nosuid"}
	} else {
		// Use all specified mount options, ignoring duplicates.
		mountOpts = append(removeInvalidMountOptions(ctx, desiredMountOpts), "cfgFile="+vol.clientConfPath)
	}

	// If SELinux is enabled, ensure we mount with some context. Use a default if one isn't provided.
	// go-selinux looks for a mounted file system with type selinuxfs. We must execute in an environment that gives us
	// a holistic view of the host's mounts for this to work.
	if selinux.GetEnabled() {
		LogVerbose(ctx, "SELinux is enabled. Ensuring we mount with context.")
		mountOpts = addContextToMountOptionsIfNecessary(mountOpts)
	}

	return mountOpts
}

// addContextToMountOptionsIfNecessary returns a slice of mount options that is guaranteed to include a security
// context option. If a security context option is not included in the input slice, the return includes a default.
func addContextToMountOptionsIfNecessary(inputMountOpts []string) []string {
	for _, inputMountOpt := range inputMountOpts {
		if strings.HasPrefix(inputMountOpt, "context=") {
			// We already have some context.
			return inputMountOpts
		}
	}

	// Return mount options with a default "system_u:object_r:container_file_t:s0" context option.
	defaultContext := selinux.Context{
		"user":  "system_u",
		"role":  "object_r",
		"type":  "container_file_t",
		"level": "s0",
	}
	return append(inputMountOpts, "context="+defaultContext.Get())
}

// removeInvalidMountOptions takes a slice of mount options and returns the slice, with any duplicates and any other
// invalid mount options (such as cfgFile) removed
func removeInvalidMountOptions(ctx context.Context, inputMountOpts []string) []string {
	var mountOpts []string
	for _, opt := range inputMountOpts {
		if strings.Contains(strings.ToLower(opt), "cfgfile") {
			// The cfgFile mount option is automatically added by our driver, so we ignore a cfgFile provided by the user
			LogDebug(ctx, "Explicit cfgFile mount option specified. Ignoring.")
			continue
		}

		present := false
		for _, existingOpt := range mountOpts {
			if opt == existingOpt {
				present = true
				break
			}
		}
		if !present {
			mountOpts = append(mountOpts, opt)
		}
	}
	return mountOpts
}

// unmountAndCleanUpIfNecessary cleans up a mounted BeeGFS filesystem ONLY if it is not bind mounted somewhere
// else. This is necessary to avoid trying to unmount a BeeGFS filesystem that is still in use by some container.
// "Cleans up" in this context means unmounts the BeeGFS filesystem, deletes the mount point (mountPath), and deletes
// all files under mountDirPath. unmountAndCleanUpIfNecessary also deletes mountDirPath if rmDir is set to true.
// unmountAndCleanUpIfNecessary quietly continues WITHOUT error if the BeeGFS filesystem is not mounted.
func unmountAndCleanUpIfNecessary(ctx context.Context, vol beegfsVolume, rmDir bool, mounter mount.Interface) (err error) {
	// Decide whether or not to unmount BeeGFS filesystem by checking whether it is bind mounted somewhere else. We
	// cannot use beegfsMounter.GetRefs() because we are bind mounting subdirectories (e.g. .../volume1/mount is the
	// initial mount point but .../volume1/mount/volume1 is the directory we bind mount). beegfsMounter.GetRefs() is
	// incapable of discovering this.
	allMounts, err := mounter.List()
	if err != nil {
		return errors.Wrap(err, "error listing mounted filesystems")
	}

	// Get a relative path to exclude from the bind mount check like isolatedMountDirPath/mount. Do not exclude
	// mountPath directly, as it is an absolute path and therefore too specific.
	isolatedMountDirPath := path.Base(vol.mountDirPath)
	exclude := path.Join(isolatedMountDirPath, "mount")
	for _, entry := range allMounts {
		// Our container mounts the host's root filesystem at /host (like /:/host), so a file system might appear to be
		// mounted at both /mountPath and /host/mountPath. Nomad automatically mounts our data directory into our
		// container at /csi/local (in addition to the location we intentionally mount it). We can not use /csi/local/
		// as part of our mountDirPath because our container and the host must agree on the path of beegfs-client.conf,
		// so a file system might appear to be mounted at both .../isolatedMountDirPath/mount and
		// /csi/local/isolatedMountDirPath/mount. These duplicate examples above are NOT the bind mounts we care about,
		// so we filter on isolatedMountDirPath/mount.
		if entry.Device == "beegfs_nodev" && !strings.Contains(entry.Path, exclude) {
			for _, opt := range entry.Opts {
				if strings.Contains(opt, vol.clientConfPath) {
					// This is a bind mount of the BeeGFS filesystem mounted at mountPath
					return errors.Errorf("refused to unmount staged file system at %s while bind mounted at %s",
						vol.mountPath, entry.Path)
				}
			}
		}
	}

	LogDebug(ctx, "Unmounting volume from path", "volumeID", vol.volumeID, "path", vol.mountPath)
	if err = mount.CleanupMountPoint(vol.mountPath, mounter, false); err != nil {
		return errors.WithStack(err)
	}
	if err = cleanUpIfNecessary(ctx, vol, rmDir); err != nil {
		return errors.WithMessagef(err, "failed to clean up %s for %s", vol.mountDirPath, vol.volumeID)
	}
	return nil
}

// cleanUpIfNecessary deletes all files associated with a beegfsVolume (in vol.mountDirPath) that is not mounted. It
// also deletes vol.mountDirPath if rmDir is set to true.
func cleanUpIfNecessary(ctx context.Context, vol beegfsVolume, rmDir bool) (err error) {
	LogDebug(ctx, "Cleaning up path", "path", vol.mountDirPath, "volumeID", vol.volumeID)
	if rmDir == false {
		dir, err := ioutil.ReadDir(vol.mountDirPath)
		if err != nil {
			return errors.WithStack(err)
		}
		for _, d := range dir {
			if err = fs.RemoveAll(path.Join(vol.mountDirPath, d.Name())); err != nil {
				return errors.WithStack(err)
			}
		}
	} else {
		if err = fs.RemoveAll(vol.mountDirPath); err != nil {
			return errors.WithStack(err)
		}
	}
	return nil
}

// getEphemeralPortUDP either returns an error or the system-assigned ephemeral port of a temporary UDP/IPv4 socket bound to INADDR_ANY.
// Note: This only exists because BeeGFS does not support setting connClientPortUDP to zero.
// Warning: Other processes on the host may bind the port returned before BeeGFS binds it.  Calling this method in a retry loop may mitigate that issue.  Ideally, BeeGFS itself should be patched to support binding to port zero.
func getEphemeralPortUDP() (port int, err error) {
	conn, err := net.ListenPacket("udp4", "")
	if err != nil {
		err = errors.WithStack(err)
		return 0, err
	}
	defer func() {
		if closeErr := conn.Close(); closeErr != nil {
			closeErr = errors.WithStack(closeErr)
			if err != nil {
				err = errors.WithMessage(err, closeErr.Error())
			} else {
				err = closeErr
			}
		}
	}()
	lAddr := conn.LocalAddr()
	lUDPAddr, err := net.ResolveUDPAddr(lAddr.Network(), lAddr.String())
	if err != nil {
		err = errors.WithStack(err)
		return 0, err
	}
	return lUDPAddr.Port, nil
}

// sanitizeVolumeID takes a volumeID like beegfs://127.0.0.1/scratch/vol1 and returns a string like
// 127.0.0.1_scratch_vol1. It is primarily used to generate sane directory names for the controller service, but may
// find other uses. sanitizeVolumeID replaces any _ in the provided volumeID with __ in the output to reduce ambiguity.
// sanitizeVolumeID returns a sha1 hash of the volumeID if the sanitized volumeID would be over 255 characters (the
// length limit for a file name in many file systems).
func sanitizeVolumeID(volumeID string) string {
	sanitizedVolumeID := strings.Replace(volumeID, "beegfs://", "", 1)
	sanitizedVolumeID = strings.Replace(sanitizedVolumeID, "_", "__", -1) // preserve existing _ as __
	sanitizedVolumeID = strings.Replace(sanitizedVolumeID, "/", "_", -1)
	if len(sanitizedVolumeID) > 255 {
		return fmt.Sprintf("%x", sha1.Sum([]byte(volumeID)))
	}
	return sanitizedVolumeID
}

// isValidVolumeCapability is a helper function used to call isValidVolumeCapabilities on a single VolumeCapability.
func isValidVolumeCapability(volCap *csi.VolumeCapability) (valid bool, reason string) {
	return isValidVolumeCapabilities([]*csi.VolumeCapability{volCap})
}

// isValidVolumeCapabilities checks a slice of VolumeCapabilities for support. If it finds an incompatible
// VolumeCapability, it returns false and a reason for the incompatibility.
func isValidVolumeCapabilities(volCaps []*csi.VolumeCapability) (valid bool, reason string) {
	// Our volumes support all access modes. Block volumes are not supported.
	for _, c := range volCaps {
		if c.GetMount() == nil || c.GetBlock() != nil {
			return false, "access_type must be MountVolume"
		}
	}
	return true, ""
}

// isBeegfsClientModuleLoaded determines if the BeeGFS client kernel module is loaded
// for the current running kernel. An error is returned if the beegfs module is not found
// or if the lsmod command fails to execute.
func isBeegfsClientModuleLoaded() (status bool, err error) {
	var stdoutBuffer bytes.Buffer
	var stderrBuffer bytes.Buffer

	// Attempt to use "lsmod" to verify the BeeGFS module is running.
	cmd := exec.Command("lsmod")
	cmd.Stdout = &stdoutBuffer
	cmd.Stderr = &stderrBuffer
	LogDebug(context.TODO(), "Executing command", "command", cmd.Args)
	err = cmd.Run()
	stdOutString := stdoutBuffer.String()
	stdErrString := stderrBuffer.String()
	if err != nil {
		return false, errors.Wrapf(err, "lsmod failed with stdOut: %s and stdErr: %s", stdOutString, stdErrString)
	}
	if strings.Contains(stdOutString, "beegfs") {
		LogDebug(context.TODO(), "Found the BeeGFS client module with lsmod")
		return true, nil
	} else {
		return false, nil
	}
}

// isBeegfsClientModuleInstalled determines if the BeeGFS client kernel module is installed
// for the currently running kernel. An error is returned if the kernel module is not found.
func isBeegfsClientModuleInstalled() (status bool, err error) {
	var stdoutBuffer bytes.Buffer
	var stderrBuffer bytes.Buffer

	cmd := exec.Command("modprobe", "-R", "beegfs")
	cmd.Stdout = &stdoutBuffer
	cmd.Stderr = &stderrBuffer
	LogDebug(context.TODO(), "Executing command", "command", cmd.Args)
	err = cmd.Run()
	stdOutString := stdoutBuffer.String()
	stdErrString := stderrBuffer.String()
	moduleNotFound := "exit status 1"
	if err != nil {
		if err.Error() == moduleNotFound {
			// The command completed and did not find the module
			return false, nil
		} else {
			// There was some actual error with the command
			err = errors.Wrapf(err, "modprobe execution failed with stdOut: %s and stdErr: %s", stdOutString, stdErrString)
			return false, err
		}
	}
	LogDebug(context.TODO(), "Found the BeeGFS client module with modprobe")
	return true, nil
}

// verifyBeegfsClientModuleIsAvailable attempts to confirm that the BeeGFS client module either is running or can run.
// It returns nil if this requirement is met and a descriptive error from a failed check if it is not.
func verifyBeegfsClientModuleIsAvailable() error {
	isLoaded, loadedError := isBeegfsClientModuleLoaded()
	if loadedError != nil {
		LogError(context.TODO(), loadedError, "An error occurred checking the loaded modules for beegfs")
	}
	if isLoaded {
		LogDebug(context.TODO(), "The BeeGFS client module is loaded")
		return nil
	}
	isInstalled, installedError := isBeegfsClientModuleInstalled()
	if installedError != nil {
		return errors.WithMessage(installedError, "unable to determine if the beegfs module is installed")
	}
	if isInstalled {
		LogDebug(context.TODO(), "The BeeGFS client module is installed but not loaded")
		return nil
	}
	return errors.New("the BeeGFS client kernel module is not installed")
}
